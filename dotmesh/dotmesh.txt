DotMesh
Liberate your (?)

Install your own microblogging.
Share with your friends, school or univercity.
Integrate with Twitter to make your posts visible to everybody.
Your messages are stored on your own server
Cons: manage backups by yourself

Screens:

Setup
	Node subform
	Admin user subform
	
Home
	Login subform
		Login using Twitter
	Search subform
		Local
		Remote Tracker
	New Post
		Public/Private
		Post on Twitter
		Attach files (?)
		Markdown, youtube/image embed by link
	My subscriptions (filter by, manage)
		Users
		Tags
	My subscriptions Timeline
		Each post actions
			Star
			Thumbs up
			Thumbs down
			Report
			Reply
			Echo
			Share
		My post actions
			Edit
			Delete
			Toggle private

Post
	Thread
	Reply
	Go back to referrer site
	
Tag timeline
	All messages tagged
	
Search results
	All messages on the node matching search
	
Sign Up

Recover/reset password

My Account
	Username
	Thumbnail
	Name
	Email
	Reset Password (link to send an email)
	
Admin page
	Manage users
	Manage posts
	Manage blocked nodes and users

QUERIES:

join feedback if logged in

HOME PAGE:

Only for local logged in users.
Shows posts made or echoed by logged in user, or subscribed to user or tag, or mentioning subscribed user.

-- Post data
select * from dm_post p
-- Post origin Node data
	inner join dm_node n on n.id=p.node_id
-- Post origin User data
	inner join dm_user u on u.id=p.user_id
-- Post echo user data (if was echoed)
	left join dm_user eu on eu.id=p.echo_user_id
-- Post feedback data for logged in user
	left join dm_post_feedback pf on pf.post_id=p.id and pf.user_id={$uId}
where
-- Post is made or echoed by me?
	(p.user_id={$uId} or p.echo_user_id={$uId})
	or (
-- is post public?
		p.is_public 
		and (
-- Post is created by followed user?
			p.user_id in (select pub_user_id from dm_user_sub where sub_user_id={$uId})
-- Post is echoed by followed user?
			or p.echo_user_id in (select pub_user_id from dm_user_sub where sub_user_id={$uId})
-- Is echo user not blocked?
				and p.echo_user_id not in (select block_user_id from dm_user_block where user_id={$uId})
-- Post has followed tag?
			or p.id in (select post_id from dm_post_tag pt inner join dm_tag_sub ts on ts.pub_tag_id=pt.id where ts.sub_user_id={$uId})
		)
-- Post mentions logged in user?
		or p.id in (select post_id from dm_post_user where user_id={$uId})
	)
-- Node is not globally blocked?
	and n.is_blocked=0
-- User is not globally blocked?
	and u.is_blocked=0
-- If post was echoed, echo user is not blocked?
	and (p.echo_user_id is null or eu.is_blocked=0)
-- Node is not blocked by logged in user?
	and p.node_id not in (select block_node_id from dm_node_block where user_id={$uId})
-- Origin user is not blocked by logged in user?
	and p.user_id not in (select block_user_id from dm_user_block where user_id={$uId}) 
;

TAG PAGE:

If logged in user, shows local tagged posts public or mentioning logged in user
If guest, shows public tagged posts. 

select * from dm_post p
	left join dm_post_feedback pf on pf.post_id=p.id and pf.user_id={$uId}
where 
	p.id in (select post_id from dm_post_tag where tag_id={$tagId}) 
	and (
		p.is_public 
		or p.id in (select post_id from dm_post_user where user_id={$uId})
	)
	and p.node_id not in (select block_node_id from dm_node_block where user_id={$uId})
	and p.user_id not in (select block_user_id from dm_user_block where user_id={$uId}) 
;

USER PAGE:

If logged in user, shows public or mentioning logged in user
If guest, shows public posts made or echoed by the user

select * from dm_post p
	left join dm_post_feedback pf on pf.post_id=p.id and pf.user_id={$uId}
where 
	(p.user_id={$pubUserId} or p.echo_user_id={$pubUserId})
	and (
		p.is_public 
		or p.id in (select post_id from dm_post_user where user_id={$uId})
	)
	and p.node_id not in (select block_node_id from dm_node_block where user_id={$uId})
	and p.user_id not in (select block_user_id from dm_user_block where user_id={$uId}) 
;

POST PAGE:

Shows post or thread, echoed by whom

replace parent_id with thread_id


Fetch by last create_dt

API points
Angular or not???

GET /n/info.json

POST /n/{id}.json


POST /u/{user}.json
GET /u/{user}.(png|jpg|gif) - thumbnail

POST /t/{tag}.json


POST /p/{post}.json
	score +1/-1
	star
	report
	echo
	

CODE:

class DotMesh_Model_Node {
	protected static $_autoCache = true;
	
	public static function find($uri, $create=false) {
		$node = static::load($uri, 'uri');
		if (!$node && $create) {
			$node = static::create(array('uri'=>$uri))->fetchInfo()->save();
		}
		return $node;
	}
	
	public function fetchInfo() {
		$info = BUtil::fromJson(BUtil::httpGet($this->uri.'/n/info.json'));
		$this->is_https = $info['is_https'];
		$this->is_modrewrite = $info['is_modrewrite'];
		return $this;
	}
	
	public function uri($type=null) {
		$uri = $this->is_https ? 'https' : 'http';
		$uri .= '://'.trim($this->uri,'/');
		if ($type) {
			$uri .= '/'.$type;
		}
		return $uri;
	}
}

class DotMesh_Model_User {
	public static function parseUri($uri) {
		//... parse_url()
		return array($nodeUri, $username);
	}
	
	public static function find($uri, $signature, $create=false) {
		array($nodeUri, $username) = static::parseUri($uri);
		$node = DotMesh_Model_Node::i()->find($nodeUri);
		//$node->is_blocked?
		$data = array('node_id'=>$node->id, 'username'=>$username);
		$user = static::load($data);
		if (!$user && $create) {
			$user = static::create($data)->save();
		}
		if ($user && $user->remote_signature!==$signature) {
			$user->confirmSignature($signature);
		}
		return $user;
	}
	
	public function node()
	{
		if (!$this->node) {
			$this->node = DotMesh_Model_Node::i()->load($this->node_id);
		}
		return $this->node;
	}
	
	public function uri()
	{
		return $this->node()->uri('u').'/'.$this->username;
	}
	
	public function confirmRemoteSignature($signature)
	{
		$result = BUtil::fromJson(BUtil::httpPost($this->uri().'.json', array(
			'do' => 'confirm_signature',
			'signature' => $signature,
			'node_info' => $this->node()->info(),
		)));
		if ($result && $result['status']=='success') {
			$this->remote_signature = $signature;
		}
		return $this;
	}
}

First time remote user - server handshake
1. CORS comes from user browser, including local_user.uri, user.signature unique to 2 domains: dotmesh.net/myrth
2. If unknown user or signature doesn't match, target node sends confirmation request to dotmesh.net with self info, local_user.uri, signature.
3. Origin node validates remote server IP resolution and responds true or false, local_user.public_key, and self info.
4. Target node saves user.signature.
5. Signature is bcrypt hash of random_salt+(local_node.private_key+user.private_key+remote_node.uri)
6. Private keys for node and user generated on creation.


DO NOT CREATE SESSION IF NOT NEEDED.
CREATE session on BSession::dataToUpdate(), and OPEN on BSession::data() if SID is set